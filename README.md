# RayLang

This is a work in progress of RayLang, a programming language with RustLike syntax designed to be in between Rust and C.
Currently only basic syntax is implemented like the one bellow:

```rust
fn fib(n: i32) -> i32{
	if n <= 1 {
		return n;
	}
	return fib(n - 1) + fib(n - 2);
}
```

# requirements
- [Meson](https://mesonbuild.com/) is required to build the project.
- [Ninja](https://ninja-build.org/) (optional) to build the project.
- any C compiler like [GCC](https://gcc.gnu.org/) or [Clang](https://clang.llvm.org/)

# building
to build the project run the following command:

```bash
meson setup builddir --buildtype=release
meson compile -C builddir
```

this will create a `rayc` executable in the `builddir` folder.
> builddir/RayC/RayC(.exe)

# Features

currently only basic transpilation of C function and some control flow are implemented.
but the goal is to have a basic frontend transpiler to C and eventually boostrap itself to a full language.
including C transpilation and WebAssembly text generation.

the type checker, symbol table, function table and module system is not implemented yet.
so there is no validation of those types, still as long your code is valid it should output valid C code like the example bellow:


<details>
<summary>
<b>example.ray</b>
</summary>

```rust

struct String{
	array_size: usize;
	element_count: usize;
	array: [u8;];
}

struct FILE;
fn fwrite(buffer: void*, elementSize: usize, elementCount: usize, stream: mut FILE*) -> usize;
fn malloc(size: usize) -> void*;
fn get_stdout() -> mut FILE*;
fn getNumberDigits(digits: i32) -> usize;

fn print(str: String){
	fwrite(str.array, sizeof(u8), str.element_count, get_stdout());
}

fn itos(num: i32) -> String{
	let mut n: i32 = num;
	let mut size: usize = getNumberDigits(n);
	let mut array: [u8;] = malloc(size) as mut [u8;];
	let i: usize = (size - 1);
	while n != 0 {
		array[i--] = (n % 10) + '0';
		n /= 10;
	}
	let mut result: String;
	result.array_size = size;
	result.element_count = size;
	result.array = array;
	return result;
}


fn c_memcpy(dest: mut [u8;], src: [u8;], size: usize){
	let mut i: usize = 0;
	while i < size {
		dest[i] = src[i];
		i += 1;
	}
}

fn from_string(array: [u8;], size: usize) -> String{
	let mut result: String;
	result.array_size = size;
	result.element_count = size;
	result.array = malloc(size) as mut [u8;];
	c_memcpy(result.array, array, size);
	return result;
}

fn c_strlen(array: [u8;]) -> usize{
	let mut size: usize = 0;
	while array[size++] != 0 {
	}
	return size;
}

fn from_c_string(array: [u8;]) -> String{
	return from_string(array, c_strlen(array));
}

fn RayMain() -> i32{
	let a: i32 = 2;
	let b: i32= 5;
	let result: i32 = a + b;
	print(itos(a));
	print(from_c_string(" + "));
	print(itos(b));
	print(from_c_string(" = "));
	print(itos(result));
	print(from_c_string("\n"));
	return 0;
}
```

</details>
then you can run the transpiler like this:

```bash
rayc.exe playground.ray -o out.c -t c_source
```
this will output the following C code:

<details>
<summary>
<b>out.c</b>
</summary>

```c
// this file was generated by RayLang C transpiler
#ifdef __cplusplus
extern "C" {
#endif
#include <stdint.h>
#define i8 int8_t
#define u8 uint8_t
#define i32 int32_t
#define isize intmax_t
#define usize uintmax_t
#define c_char char
#define RAY_MACRO_ARRAY_FIXED(T, X, N) T X[N]
typedef struct String {
	usize array_size;
	usize element_count;
	u8 *array;
} String;
typedef struct FILE FILE;
usize fwrite(const void* buffer, const usize elementSize, const usize elementCount, FILE* stream);
void* malloc(const usize size);
FILE* get_stdout();
usize getNumberDigits(const i32 digits);
void print(const String str) {
	fwrite(str.array, sizeof(u8), str.element_count, get_stdout());
}
String itos(const i32 num) {
	i32 n = num;
	usize size = getNumberDigits(n);
	u8 *array = (u8 *)(malloc(size));
	usize i = size - 1;
	while (n != 0) {
		array[i--] = n % 10 + (const u8){0x30};
		n /= 10;
	}
	String result;
	result.array_size = size;
	result.element_count = size;
	result.array = array;
	return result;
}
void c_memcpy(u8 *dest, const u8 *src, const usize size) {
	usize i = 0;
	while (i < size) {
		dest[i] = src[i];
		i += 1;
	}
}
String from_string(const u8 *array, const usize size) {
	String result;
	result.array_size = size;
	result.element_count = size;
	result.array = (u8 *)(malloc(size));
	c_memcpy(result.array, array, size);
	return result;
}
usize c_strlen(const u8 *array) {
	usize size = 0;
	while (array[size++] != 0) {
	}
	return size;
}
String from_c_string(const u8 *array) {
	return from_string(array, c_strlen(array));
}
i32 RayMain() {
	i32 a = 2;
	i32 b = 5;
	i32 result = a + b;
	print(itos(a));
	print(from_c_string((const u8[]){0x20, 0x2B, 0x20, 0x00}/*" + "*/));
	print(itos(b));
	print(from_c_string((const u8[]){0x20, 0x3D, 0x20, 0x00}/*" = "*/));
	print(itos(result));
	print(from_c_string((const u8[]){0x0A, 0x00}/*"\n"*/));
	return 0;
}
#ifdef __cplusplus
}
#endif


```
</details>
and then you can define your own main function and declared functions like this:

<details>
<summary>
	<b>CEntry.c</b>
</summary>

```c
#include <math.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

FILE *get_stdout() { return stdout; }

size_t getNumberDigits(int32_t digits) { return (size_t)ceil(log10(digits)); }

int32_t RayMain();

int main() { return RayMain(); }
```

</details>

finally compile the C code with your own main function like this:

```bash
cc out.c CEntry.c -o out-c
```

which will output the following:

```bash
$ ./out-c
2 + 5 = 7
```

