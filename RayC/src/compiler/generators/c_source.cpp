
#include <ray/compiler/ast/expression.hpp>
#include <ray/compiler/ast/statement.hpp>
#include <ray/compiler/generators/c_source.hpp>
#include <ray/compiler/lexer/token.hpp>

#include <format>
#include <iostream>
#include <ranges>
#include <string>

namespace ray::compiler::generator {

std::string CSourceGenerator::currentIdent() const {
	return std::string(ident, '\t');
}

void CSourceGenerator::resolve(
    const std::vector<std::unique_ptr<ast::Statement>> &statement) {
	output.clear();
	output << "//this file was generated by RayLang C transpiler\n";
	output << "#ifdef __cplusplus\n";
	output << "extern \"C\" {\n";
	output << "#endif\n";
	output << "#include <stdint.h>\n";
	output << "#define i32 int32_t\n";
	// ident++;
	for (const auto &stmt : statement) {
		stmt->visit(*this);
	}
	// ident--;
	output << "#ifdef __cplusplus\n";
	output << "}\n";
	output << "#endif\n";
}

bool CSourceGenerator::hasFailed() const { return false; }

std::string CSourceGenerator::getOutput() const { return output.str(); }

// Statement
void CSourceGenerator::visitBlockStatement(const ast::Block &block) {
	if (block.statements.size() > 0) {
		for (auto &statement : block.statements) {
			statement->visit(*this);
		}
	}
}
void CSourceGenerator::visitTerminalExprStatement(
    const ast::TerminalExpr &terminalExpr) {
	if (terminalExpr.expression.has_value()) {
		terminalExpr.expression->get()->visit(*this);
		output << std::format("{}return;\n", currentIdent());
	}
}
void CSourceGenerator::visitExpressionStmtStatement(
    const ast::ExpressionStmt &expression) {
	expression.expression->visit(*this);
	output << std::format(";\n", currentIdent());
}
void CSourceGenerator::visitFunctionStatement(const ast::Function &function) {

	std::string identTabs = currentIdent();
	std::string functionName;
	functionName.reserve(function.name.lexeme.size() + 12);
	functionName = function.name.lexeme;
	output << identTabs;
	if (function.returnType.name.type != Token::TokenType::TOKEN_TYPE_UNIT) {
		output << std::format("{} ", function.returnType.name.lexeme);
	} else {
		output << std::format("void ");
	}
	output << std::format("{}(", functionName);
	for (auto &parameter : function.params) {
		output << std::format(" (param ${} {})", parameter.name.lexeme,
		                      parameter.type.name.lexeme);
	}
	output << "){\n";
	ident++;
	function.body.visit(*this);
	ident--;
	output << std::format("{}}}\n", identTabs);
	if (function.publicVisibility) {
		output << std::format("{}(export \"{}\" (func ${}))\n", identTabs,
		                      functionName, functionName);
	}
}
void CSourceGenerator::visitIfStatement(const ast::If &ifStatement) {
	ifStatement.condition->visit(*this);
	output << std::format("{}(if\n", currentIdent());
	ident++;
	output << std::format("{}(then\n", currentIdent());
	ident++;
	ifStatement.thenBranch->visit(*this);
	ident--;
	output << std::format("{})\n", currentIdent());
	if (ifStatement.elseBranch.has_value()) {
		output << std::format("{}else\n", currentIdent());
		ident++;
		ifStatement.elseBranch->get()->visit(*this);
		ident--;
	}
	ident--;
	output << std::format("{})\n", currentIdent());
}
void CSourceGenerator::visitJumpStatement(const ast::Jump &jump) {
	std::string identTab = currentIdent();
	switch (jump.keyword.type) {
	case Token::TokenType::TOKEN_BREAK:
		output << std::format("{}br 0\n", identTab);
		break;
	case Token::TokenType::TOKEN_CONTINUE:
		output << std::format("{}br 1\n", identTab);
		break;
	case Token::TokenType::TOKEN_RETURN:
		output << std::format("{}return", identTab);
		if (jump.value.has_value()) {
			output << " ";
			auto currentIdent = ident;
			ident = 0;
			jump.value.value()->visit(*this);
			ident = currentIdent;
		}
		output << ";\n";
		break;
	default:
		std::cerr << std::format("'{}' is not a supported jump type\n",
		                         jump.keyword.getLexeme());
		break;
	}
}
void CSourceGenerator::visitVarStatement(const ast::Var &var) {
	std::string identTab = currentIdent();
	output << std::format("{}i32 {}", identTab, var.name.lexeme);
	if (var.initializer.has_value()) {
		output << " = ";
		auto initializer = var.initializer->get();
		auto currentIdent = ident;
		ident = 0;
		initializer->visit(*this);
		ident = currentIdent;
	}
	output << ";\n";
}
void CSourceGenerator::visitWhileStatement(const ast::While &value) {
	std::cerr << "visitWhileStatement not implemented\n";
}
// Expression
void CSourceGenerator::visitAssignExpression(const ast::Assign &value) {
	std::string identTab = currentIdent();
	value.value->visit(*this);
	output << std::format("{}local.tee ${}\n", identTab, value.name.lexeme);
}
void CSourceGenerator::visitBinaryExpression(
    const ast::Binary &binaryExpression) {
	std::string identTab = currentIdent();
	binaryExpression.left->visit(*this);

	auto op = binaryExpression.op;
	switch (op.type) {
	case Token::TokenType::TOKEN_PLUS:
	case Token::TokenType::TOKEN_MINUS:
	case Token::TokenType::TOKEN_STAR:
	case Token::TokenType::TOKEN_SLASH:
	case Token::TokenType::TOKEN_PERCENT:
	case Token::TokenType::TOKEN_AMPERSAND:
	case Token::TokenType::TOKEN_PIPE:
	case Token::TokenType::TOKEN_CARET:
	case Token::TokenType::TOKEN_LESS_LESS:
	case Token::TokenType::TOKEN_GREAT_GREAT:
	case Token::TokenType::TOKEN_LESS:
	case Token::TokenType::TOKEN_GREAT:
	case Token::TokenType::TOKEN_LESS_EQUAL:
	case Token::TokenType::TOKEN_GREAT_EQUAL:
		output << std::format(" {} ", Token::glyph(op.type));
		break;
	default:
		std::cerr << std::format("'{}' is not a supported binary operation\n",
		                         op.getLexeme());
	}

	binaryExpression.right->visit(*this);
}
void CSourceGenerator::visitCallExpression(const ast::Call &callable) {
	// check if the callable contains a function
	if (ast::Variable *var =
	        dynamic_cast<ast::Variable *>(callable.callee.get())) {
		output << std::format("{}{}(", currentIdent(), var->name.lexeme);

		for (auto const &[index, argument] :
		     callable.arguments | std::views::enumerate) {
			auto currentIdent = ident;
			ident = 0;
			argument->visit(*this);
			ident = currentIdent;
			if (index < callable.arguments.size() - 1) {
				output << ", ";
			}
		}
		output << ")";
	} else {
		std::cerr << std::format("'{}' is not a supported callable type\n",
		                         callable.callee.get()->variantName());
	}
}
void CSourceGenerator::visitGetExpression(const ast::Get &value) {
	std::cerr << "visitGetExpression not implemented\n";
}
void CSourceGenerator::visitGroupingExpression(const ast::Grouping &grouping) {
	grouping.expression->visit(*this);
}
void CSourceGenerator::visitLiteralExpression(const ast::Literal &literal) {
	switch (literal.kind.type) {
	case Token::TokenType::TOKEN_TRUE:
	case Token::TokenType::TOKEN_FALSE:
		output << std::format(
		    "{}{}", currentIdent(),
		    literal.kind.type == Token::TokenType::TOKEN_TRUE ? "true" : "false");
		break;
	case Token::TokenType::TOKEN_NUMBER: {
		std::string value = literal.value;
		output << std::format("{}{}", currentIdent(), value);
		break;
	}
	case Token::TokenType::TOKEN_STRING:
		output << std::format("\"{}\"", literal.value);
		break;
	default:
		std::cerr << std::format("'{}' ({}) is not a supported literal type\n",
		                         literal.kind.getLexeme(),
		                         Token::glyph(literal.kind.type));
		break;
	}
	if (ident != 0) {
		output << "\n";
	}
}
void CSourceGenerator::visitLogicalExpression(const ast::Logical &value) {
	std::cerr << "visitLogicalExpression not implemented\n";
}
void CSourceGenerator::visitSetExpression(const ast::Set &value) {
	std::cerr << "visitSetExpression not implemented\n";
}
void CSourceGenerator::visitUnaryExpression(const ast::Unary &unary) {
	unary.right->visit(*this);
	switch (unary.op.type) {
	case Token::TokenType::TOKEN_BANG:
	case Token::TokenType::TOKEN_MINUS:
	case Token::TokenType::TOKEN_MINUS_MINUS:
	case Token::TokenType::TOKEN_PLUS_PLUS:
		output << std::format("{}{}\n", currentIdent(), unary.op.getLexeme());
		break;
	default:
		std::cerr << std::format("'{}' is not a supported unary operation\n",
		                         unary.op.getLexeme());
	}
}
void CSourceGenerator::visitVariableExpression(const ast::Variable &variable) {
	std::string identTab = currentIdent();
	output << std::format("{}{}", identTab, variable.name.lexeme);
}
void CSourceGenerator::visitTypeExpression(const ast::Type &value) {
	std::cerr << "visitTypeExpression not implemented\n";
}
void CSourceGenerator::visitParameterExpression(const ast::Parameter &value) {
	std::cerr << "visitParameterExpression not implemented\n";
}

} // namespace ray::compiler::generator
