
#include <ray/compiler/ast/expression.hpp>
#include <ray/compiler/ast/statement.hpp>
#include <ray/compiler/generators/c_source.hpp>
#include <ray/compiler/lexer/token.hpp>

#include <format>
#include <iostream>
#include <string>

namespace ray::compiler::generator {

std::string CSourceGenerator::currentIdent() const {
	return std::string(ident, '\t');
}

void CSourceGenerator::resolve(
    const std::vector<std::unique_ptr<ast::Statement>> &statement) {
	output.clear();
	output << "// this file was generated by RayLang C transpiler\n";
	output << "#ifdef __cplusplus\n";
	output << "extern \"C\" {\n";
	output << "#endif\n";
	// some of the definitions are technically UB as they may not be exactly 32
	// or 64 bit implementations but generally they use the IEEE 754 format,
	// assuming that is true
	output << "#include <stdint.h>\n";
	output << "#define i8 int8_t\n";
	output << "#define u8 uint8_t\n";
	output << "#define u32 uint32_t\n";
	output << "#define s32 int32_t\n";
	output << "#define u64 uint64_t\n";
	output << "#define s64 int64_t\n";
	output << "#define f32 float\n";
	output << "#define f64 double\n";
	output << "#define isize intmax_t\n";
	output << "#define usize uintmax_t\n";
	output << "#define c_char char\n";
	output << "#define RAY_MACRO_ARRAY_FIXED(T, X, N) T X[N]\n";
	// ident++;
	for (const auto &stmt : statement) {
		stmt->visit(*this);
	}
	// ident--;
	output << "#ifdef __cplusplus\n";
	output << "}\n";
	output << "#endif\n";
}

bool CSourceGenerator::hasFailed() const { return false; }

std::string CSourceGenerator::getOutput() const { return output.str(); }

// Statement
void CSourceGenerator::visitBlockStatement(const ast::Block &block) {
	if (block.statements.size() > 0) {
		for (auto &statement : block.statements) {
			statement->visit(*this);
		}
	}
}
void CSourceGenerator::visitTerminalExprStatement(
    const ast::TerminalExpr &terminalExpr) {
	if (terminalExpr.expression.has_value()) {
		terminalExpr.expression->get()->visit(*this);
		output << std::format("{}return;\n", currentIdent());
	}
}
void CSourceGenerator::visitExpressionStmtStatement(
    const ast::ExpressionStmt &expression) {
	output << currentIdent();
	expression.expression->visit(*this);
	output << std::format(";\n", currentIdent());
}
void CSourceGenerator::visitFunctionStatement(const ast::Function &function) {

	std::string identTabs = currentIdent();
	output << identTabs;
	if (function.returnType.name.type != Token::TokenType::TOKEN_TYPE_UNIT) {
		output << std::format("{} ", function.returnType.name.lexeme);
	} else {
		output << std::format("void ");
	}
	output << std::format("{}(", function.name.lexeme);
	for (size_t index = 0; index < function.params.size(); ++index) {
		const auto &parameter = function.params[index];
		parameter.visit(*this);
		if (index < function.params.size() - 1) {
			output << ", ";
		}
	}
	output << ")";
	if (function.body.has_value()) {
		output << " {";
		if (function.body->statements.size() > 1) {
			auto statement = dynamic_cast<ast::TerminalExpr *>(
			    function.body->statements[0].get());
			if (!statement || statement->expression.has_value()) {
				output << "\n";
				ident++;
				function.body->visit(*this);
				ident--;
			}
		}
		output << std::format("{}}}\n", identTabs);
		if (function.publicVisibility) {
			std::cerr << "pub semantics not implemented for function.\n";
		}
	} else {
		output << ";\n";
	}
}
void CSourceGenerator::visitIfStatement(const ast::If &ifStatement) {
	output << std::format("{}if (", currentIdent());
	ifStatement.condition->visit(*this);
	output << ") {\n";
	ident++;
	ifStatement.thenBranch->visit(*this);
	ident--;
	output << std::format("{}}}\n", currentIdent());
	if (ifStatement.elseBranch.has_value()) {
		output << std::format("{}else{{\n", currentIdent());
		ident++;
		ifStatement.elseBranch->get()->visit(*this);
		ident--;
		output << std::format("{}}}\n", currentIdent());
	}
}
void CSourceGenerator::visitJumpStatement(const ast::Jump &jump) {
	std::string identTab = currentIdent();
	switch (jump.keyword.type) {
	case Token::TokenType::TOKEN_BREAK:
		output << std::format("{}br 0\n", identTab);
		break;
	case Token::TokenType::TOKEN_CONTINUE:
		output << std::format("{}br 1\n", identTab);
		break;
	case Token::TokenType::TOKEN_RETURN:
		output << std::format("{}return", identTab);
		if (jump.value.has_value()) {
			output << " ";
			auto currentIdent = ident;
			ident = 0;
			jump.value.value()->visit(*this);
			ident = currentIdent;
		}
		output << ";\n";
		break;
	default:
		std::cerr << std::format("'{}' is not a supported jump type\n",
		                         jump.keyword.getLexeme());
		break;
	}
}
void CSourceGenerator::visitVarStatement(const ast::Var &var) {
	std::string identTab = currentIdent();

	if (var.type.name.lexeme.starts_with("[")) {
		output << std::format(
		    "{}{} *{}", identTab,
		    var.type.name.lexeme.substr(
		        1, var.type.name.lexeme.find_last_of("]") - 1),
		    var.name.lexeme);
	} else {
		output << std::format("{}{} {}", identTab, var.type.name.lexeme,
		                      var.name.lexeme);
	}
	if (var.initializer.has_value()) {
		output << " = ";
		auto initializer = var.initializer->get();
		auto currentIdent = ident;
		ident = 0;
		initializer->visit(*this);
		ident = currentIdent;
	}
	output << ";\n";
}
void CSourceGenerator::visitWhileStatement(const ast::While &value) {
	auto identTab = currentIdent();
	output << std::format("{}while (", identTab);
	auto currentIdent = ident;
	ident = 0;
	value.condition->visit(*this);
	ident = currentIdent;
	output << ") {\n";
	ident++;
	value.body->visit(*this);
	ident--;
	output << std::format("{}}}\n", identTab);
}
void CSourceGenerator::visitStructStatement(const ast::Struct &value) {
	output << std::format("{}typedef struct {}", currentIdent(),
	                      value.name.lexeme);
	if (!value.declaration) {
		output << " {\n";
		ident++;
		for (auto &member : value.members) {
			member.visit(*this);
		}
		ident--;
		output << std::format("{}}}", currentIdent());
	}
	output << std::format(" {};\n", value.name.lexeme);
}
void CSourceGenerator::visitNamespaceStatement(const ast::Namespace &ns) {
	std::cerr << "namespace semantics not implemented yet\n";
	for (auto &value : ns.statements) {
		value->visit(*this);
	}
}
// Expression
void CSourceGenerator::visitAssignExpression(const ast::Assign &value) {
	value.lhs->visit(*this);
	output << std::format(" {} ", Token::glyph(value.assignmentOp.type));
	value.rhs->visit(*this);
}
void CSourceGenerator::visitBinaryExpression(
    const ast::Binary &binaryExpression) {
	std::string identTab = currentIdent();
	binaryExpression.left->visit(*this);

	auto op = binaryExpression.op;
	switch (op.type) {
	case Token::TokenType::TOKEN_PLUS:
	case Token::TokenType::TOKEN_MINUS:
	case Token::TokenType::TOKEN_STAR:
	case Token::TokenType::TOKEN_SLASH:
	case Token::TokenType::TOKEN_PERCENT:
	case Token::TokenType::TOKEN_AMPERSAND:
	case Token::TokenType::TOKEN_PIPE:
	case Token::TokenType::TOKEN_CARET:
	case Token::TokenType::TOKEN_LESS_LESS:
	case Token::TokenType::TOKEN_GREAT_GREAT:
	case Token::TokenType::TOKEN_EQUAL_EQUAL:
	case Token::TokenType::TOKEN_BANG_EQUAL:
	case Token::TokenType::TOKEN_LESS:
	case Token::TokenType::TOKEN_GREAT:
	case Token::TokenType::TOKEN_LESS_EQUAL:
	case Token::TokenType::TOKEN_GREAT_EQUAL:
		output << std::format(" {} ", Token::glyph(op.type));
		break;
	default:
		std::cerr << std::format("'{}' is not a supported binary operation\n",
		                         op.getLexeme());
	}

	binaryExpression.right->visit(*this);
}
void CSourceGenerator::visitCallExpression(const ast::Call &callable) {
	// check if the callable contains a function
	if (ast::Variable *var =
	        dynamic_cast<ast::Variable *>(callable.callee.get())) {
		output << std::format("{}(", var->name.lexeme);

		for (size_t index = 0; index < callable.arguments.size(); ++index) {
			auto const &argument = callable.arguments[index];
			auto currentIdent = ident;
			ident = 0;
			argument->visit(*this);
			ident = currentIdent;
			if (index < callable.arguments.size() - 1) {
				output << ", ";
			}
		}
		output << ")";
	} else {
		std::cerr << std::format("'{}' is not a supported callable type\n",
		                         callable.callee.get()->variantName());
	}
}
void CSourceGenerator::visitGetExpression(const ast::Get &value) {
	value.object->visit(*this);
	output << std::format(".{}", value.name.lexeme);
}
void CSourceGenerator::visitGroupingExpression(const ast::Grouping &grouping) {
	grouping.expression->visit(*this);
}
void CSourceGenerator::visitLiteralExpression(const ast::Literal &literal) {
	switch (literal.kind.type) {
	case Token::TokenType::TOKEN_TRUE:
	case Token::TokenType::TOKEN_FALSE:
		output << std::format(
		    "{}", literal.kind.type == Token::TokenType::TOKEN_TRUE ? "true"
		                                                            : "false");
		break;
	case Token::TokenType::TOKEN_STRING: {
		output << "(const u8[]){";
		for (const char c : literal.value) {
			output << std::format("0x{:02X}, ", c);
		}
		output << "0x00}";
		// comment string literal
		output << "/*\"";
		for (const char c : literal.value) {
			switch (c) {
			case '\a':
				output << "\\a";
				break;
			case '\b':
				output << "\\b";
				break;
			case '\e':
				output << "\\e";
				break;
			case '\f':
				output << "\\f";
				break;
			case '\n':
				output << "\\n";
				break;
			case '\r':
				output << "\\r";
				break;
			case '\v':
				output << "\\v";
				break;
			case '\'':
				output << "'";
				break;
			case '"':
				output << '"';
				break;
			case '?':
				output << '?';
				break;
			default:
				output << c;
			}
		}
		output << "\"*/";
		break;
	}
	case Token::TokenType::TOKEN_NUMBER: {
		std::string value = literal.value;
		output << std::format("{}", value);
		break;
	}
	case Token::TokenType::TOKEN_CHAR: {
		output << std::format("(const u8){{0x{:02X}}}", literal.value[0]);
		break;
	}
	default:
		std::cerr << std::format("'{}' ({}) is not a supported literal type\n",
		                         literal.kind.getLexeme(),
		                         Token::glyph(literal.kind.type));
		break;
	}
}
void CSourceGenerator::visitLogicalExpression(const ast::Logical &value) {
	std::cerr << "visitLogicalExpression not implemented\n";
}
void CSourceGenerator::visitSetExpression(const ast::Set &value) {
	value.object->visit(*this);
	output << std::format(".{} {} ", value.name.lexeme,
	                      Token::glyph(value.assignmentOp.type));
	value.value->visit(*this);
}
void CSourceGenerator::visitUnaryExpression(const ast::Unary &unary) {
	if (!unary.isPrefix) {
		unary.expr->visit(*this);
	}
	switch (unary.op.type) {
	case Token::TokenType::TOKEN_BANG:
	case Token::TokenType::TOKEN_MINUS:
	case Token::TokenType::TOKEN_MINUS_MINUS:
	case Token::TokenType::TOKEN_PLUS_PLUS:
		output << std::format("{}", unary.op.getLexeme());
		break;
	default:
		std::cerr << std::format("'{}' is not a supported unary operation\n",
		                         unary.op.getLexeme());
	}
	if (unary.isPrefix) {
		unary.expr->visit(*this);
	}
}
void CSourceGenerator::visitArrayAccessExpression(
    const ast::ArrayAccess &value) {
	value.array->visit(*this);
	output << "[";
	value.index->visit(*this);
	output << "]";
}
void CSourceGenerator::visitVariableExpression(const ast::Variable &variable) {
	output << std::format("{}", variable.name.lexeme);
}
void CSourceGenerator::visitTypeExpression(const ast::Type &type) {
	if (type.isConst) {
		output << "const ";
	}
	if (type.name.lexeme.starts_with("[")) {
		output << std::format(
		    "{} *",
		    type.name.lexeme.substr(1, type.name.lexeme.find_last_of("]") - 1),
		    type.name.lexeme);
	} else {
		output << std::format("{} ", type.name.lexeme);
	}
}
void CSourceGenerator::visitCastExpression(const ast::Cast &value) {
	output << "(";
	value.type.visit(*this);
	output << ")(";
	value.expression->visit(*this);
	output << ")";
}
void CSourceGenerator::visitParameterExpression(const ast::Parameter &param) {
	param.type.visit(*this);
	output << std::format("{}", param.name.lexeme);
}

} // namespace ray::compiler::generator
